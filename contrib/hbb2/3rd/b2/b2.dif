diff -urN b2.orig/blake2-i.h b2/blake2-i.h
--- b2.orig/blake2-i.h	2015-06-13 13:43:34.757413700 +0200
+++ b2/blake2-i.h	2015-06-13 13:43:34.757413700 +0200
@@ -1,5 +1,5 @@
 /*
-   BLAKE2 reference source code package - optimized C implementations
+   BLAKE2 reference source code package - reference C implementations
 
    Written in 2012 by Samuel Neves <sneves@dei.uc.pt>
 
@@ -14,20 +14,22 @@
 #ifndef __BLAKE2_IMPL_H__
 #define __BLAKE2_IMPL_H__
 
-#include <stddef.h>
-#include <stdint.h>
-#include "config.h"
+#include "hbdefs.h"
+#undef NATIVE_LITTLE_ENDIAN
+#if defined( HB_LITTLE_ENDIAN )
+   #define NATIVE_LITTLE_ENDIAN
+#endif
 
-#define BLAKE2_IMPL_CAT(x,y) x ## y
-#define BLAKE2_IMPL_EVAL(x,y)  BLAKE2_IMPL_CAT(x,y)
-#define BLAKE2_IMPL_NAME(fun)  BLAKE2_IMPL_EVAL(fun, SUFFIX)
+#include <stdint.h>
 
 static inline uint32_t load32( const void *src )
 {
-#if defined(NATIVE_LITTLE_ENDIAN) && !defined(HAVE_ALIGNED_ACCESS_REQUIRED)
-  return *( uint32_t * )( src );
+#if defined(NATIVE_LITTLE_ENDIAN)
+  uint32_t w;
+  memcpy(&w, src, sizeof w);
+  return w;
 #else
-  const uint8_t *p = ( uint8_t * )src;
+  const uint8_t *p = ( const uint8_t * )src;
   uint32_t w = *p++;
   w |= ( uint32_t )( *p++ ) <<  8;
   w |= ( uint32_t )( *p++ ) << 16;
@@ -38,10 +40,12 @@
 
 static inline uint64_t load64( const void *src )
 {
-#if defined(NATIVE_LITTLE_ENDIAN) && !defined(HAVE_ALIGNED_ACCESS_REQUIRED)
-  return *( uint64_t * )( src );
+#if defined(NATIVE_LITTLE_ENDIAN)
+  uint64_t w;
+  memcpy(&w, src, sizeof w);
+  return w;
 #else
-  const uint8_t *p = ( uint8_t * )src;
+  const uint8_t *p = ( const uint8_t * )src;
   uint64_t w = *p++;
   w |= ( uint64_t )( *p++ ) <<  8;
   w |= ( uint64_t )( *p++ ) << 16;
@@ -56,8 +60,8 @@
 
 static inline void store32( void *dst, uint32_t w )
 {
-#if defined(NATIVE_LITTLE_ENDIAN) && !defined(HAVE_ALIGNED_ACCESS_REQUIRED)
-  *( uint32_t * )( dst ) = w;
+#if defined(NATIVE_LITTLE_ENDIAN)
+  memcpy(dst, &w, sizeof w);
 #else
   uint8_t *p = ( uint8_t * )dst;
   *p++ = ( uint8_t )w; w >>= 8;
@@ -69,8 +73,8 @@
 
 static inline void store64( void *dst, uint64_t w )
 {
-#if defined(NATIVE_LITTLE_ENDIAN) && !defined(HAVE_ALIGNED_ACCESS_REQUIRED)
-  *( uint64_t * )( dst ) = w;
+#if defined(NATIVE_LITTLE_ENDIAN)
+  memcpy(dst, &w, sizeof w);
 #else
   uint8_t *p = ( uint8_t * )dst;
   *p++ = ( uint8_t )w; w >>= 8;
@@ -131,9 +135,7 @@
 static inline void secure_zero_memory( void *v, size_t n )
 {
   volatile uint8_t *p = ( volatile uint8_t * )v;
-
   while( n-- ) *p++ = 0;
 }
 
 #endif
-
diff -urN b2.orig/blake2.h b2/blake2.h
--- b2.orig/blake2.h	2015-06-13 13:43:34.757413700 +0200
+++ b2/blake2.h	2015-06-13 13:43:34.757413700 +0200
@@ -1,5 +1,5 @@
 /*
-   BLAKE2 reference source code package - optimized C implementations
+   BLAKE2 reference source code package - reference C implementations
 
    Written in 2012 by Samuel Neves <sneves@dei.uc.pt>
 
@@ -17,28 +17,6 @@
 #include <stddef.h>
 #include <stdint.h>
 
-#if defined(_MSC_VER)
-  #define ALIGN(x) __declspec(align(x))
-  #if defined(DYNAMIC_LIB)
-    #if defined(DYNAMIC_LIB_EXPORT)
-      #define EXPORT_DLL __declspec(dllexport)
-    #else
-      #define EXPORT_DLL __declspec(dllimport)
-    #endif
-  #else
-    #define EXPORT_DLL
-  #endif
-#else
-  #define EXPORT_DLL
-   /* clang seems to crash in certain conditions
-      due to alignment hints */
-  #if defined(__clang__)
-    #define ALIGN(x)
-  #else
-    #define ALIGN(x) __attribute__ ((__aligned__(x)))
-  #endif
-#endif
-
 #if defined(__cplusplus)
 extern "C" {
 #endif
@@ -77,14 +55,13 @@
     uint8_t  personal[BLAKE2S_PERSONALBYTES];  // 32
   } blake2s_param;
 
-  ALIGN( 64 ) typedef struct __blake2s_state
+  typedef struct __blake2s_state
   {
     uint32_t h[8];
     uint32_t t[2];
     uint32_t f[2];
     uint8_t  buf[2 * BLAKE2S_BLOCKBYTES];
-    uint32_t buflen;
-    uint8_t  outlen;
+    size_t   buflen;
     uint8_t  last_node;
   } blake2s_state;
 
@@ -103,67 +80,64 @@
     uint8_t  personal[BLAKE2B_PERSONALBYTES];  // 64
   } blake2b_param;
 
-  ALIGN( 64 ) typedef struct __blake2b_state
+  typedef struct __blake2b_state
   {
     uint64_t h[8];
     uint64_t t[2];
     uint64_t f[2];
     uint8_t  buf[2 * BLAKE2B_BLOCKBYTES];
-    uint32_t buflen;
-    uint8_t  outlen;
+    size_t   buflen;
     uint8_t  last_node;
   } blake2b_state;
 
-  ALIGN( 64 ) typedef struct __blake2sp_state
+  typedef struct __blake2sp_state
   {
     blake2s_state S[8][1];
     blake2s_state R[1];
-    uint8_t  buf[8 * BLAKE2S_BLOCKBYTES];
-    uint32_t buflen;
-    uint8_t  outlen;
+    uint8_t buf[8 * BLAKE2S_BLOCKBYTES];
+    size_t  buflen;
   } blake2sp_state;
 
-  ALIGN( 64 ) typedef struct __blake2bp_state
+  typedef struct __blake2bp_state
   {
     blake2b_state S[4][1];
     blake2b_state R[1];
-    uint8_t  buf[4 * BLAKE2B_BLOCKBYTES];
-    uint32_t buflen;
-    uint8_t  outlen;
+    uint8_t buf[4 * BLAKE2B_BLOCKBYTES];
+    size_t  buflen;
   } blake2bp_state;
 #pragma pack(pop)
 
   // Streaming API
-  EXPORT_DLL int blake2s_init( blake2s_state *S, size_t outlen );
-  EXPORT_DLL int blake2s_init_key( blake2s_state *S, size_t outlen, const void *key, size_t keylen );
-  EXPORT_DLL int blake2s_init_param( blake2s_state *S, const blake2s_param *P );
-  EXPORT_DLL int blake2s_update( blake2s_state *S, const uint8_t *in, size_t inlen );
-  EXPORT_DLL int blake2s_final( blake2s_state *S, uint8_t *out, size_t outlen );
-
-  EXPORT_DLL int blake2b_init( blake2b_state *S, size_t outlen );
-  EXPORT_DLL int blake2b_init_key( blake2b_state *S, size_t outlen, const void *key, size_t keylen );
-  EXPORT_DLL int blake2b_init_param( blake2b_state *S, const blake2b_param *P );
-  EXPORT_DLL int blake2b_update( blake2b_state *S, const uint8_t *in, size_t inlen );
-  EXPORT_DLL int blake2b_final( blake2b_state *S, uint8_t *out, size_t outlen );
-
-  EXPORT_DLL int blake2sp_init( blake2sp_state *S, size_t outlen );
-  EXPORT_DLL int blake2sp_init_key( blake2sp_state *S, size_t outlen, const void *key, size_t keylen );
-  EXPORT_DLL int blake2sp_update( blake2sp_state *S, const uint8_t *in, size_t inlen );
-  EXPORT_DLL int blake2sp_final( blake2sp_state *S, uint8_t *out, size_t outlen );
-
-  EXPORT_DLL int blake2bp_init( blake2bp_state *S, size_t outlen );
-  EXPORT_DLL int blake2bp_init_key( blake2bp_state *S, size_t outlen, const void *key, size_t keylen );
-  EXPORT_DLL int blake2bp_update( blake2bp_state *S, const uint8_t *in, size_t inlen );
-  EXPORT_DLL int blake2bp_final( blake2bp_state *S, uint8_t *out, size_t outlen );
+  int blake2s_init( blake2s_state *S, const uint8_t outlen );
+  int blake2s_init_key( blake2s_state *S, const uint8_t outlen, const void *key, const uint8_t keylen );
+  int blake2s_init_param( blake2s_state *S, const blake2s_param *P );
+  int blake2s_update( blake2s_state *S, const uint8_t *in, uint64_t inlen );
+  int blake2s_final( blake2s_state *S, uint8_t *out, uint8_t outlen );
+
+  int blake2b_init( blake2b_state *S, const uint8_t outlen );
+  int blake2b_init_key( blake2b_state *S, const uint8_t outlen, const void *key, const uint8_t keylen );
+  int blake2b_init_param( blake2b_state *S, const blake2b_param *P );
+  int blake2b_update( blake2b_state *S, const uint8_t *in, uint64_t inlen );
+  int blake2b_final( blake2b_state *S, uint8_t *out, uint8_t outlen );
+
+  int blake2sp_init( blake2sp_state *S, const uint8_t outlen );
+  int blake2sp_init_key( blake2sp_state *S, const uint8_t outlen, const void *key, const uint8_t keylen );
+  int blake2sp_update( blake2sp_state *S, const uint8_t *in, uint64_t inlen );
+  int blake2sp_final( blake2sp_state *S, uint8_t *out, uint8_t outlen );
+
+  int blake2bp_init( blake2bp_state *S, const uint8_t outlen );
+  int blake2bp_init_key( blake2bp_state *S, const uint8_t outlen, const void *key, const uint8_t keylen );
+  int blake2bp_update( blake2bp_state *S, const uint8_t *in, uint64_t inlen );
+  int blake2bp_final( blake2bp_state *S, uint8_t *out, uint8_t outlen );
 
   // Simple API
-  EXPORT_DLL int blake2s( uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen );
-  EXPORT_DLL int blake2b( uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen );
+  int blake2s( uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen );
+  int blake2b( uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen );
 
-  EXPORT_DLL int blake2sp( uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen );
-  EXPORT_DLL int blake2bp( uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen );
+  int blake2sp( uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen );
+  int blake2bp( uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen );
 
-  static inline int blake2( uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen )
+  static inline int blake2( uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen )
   {
     return blake2b( out, in, key, outlen, inlen, keylen );
   }
diff -urN b2.orig/blake2b.c b2/blake2b.c
--- b2.orig/blake2b.c	2015-06-13 13:43:34.757413700 +0200
+++ b2/blake2b.c	2015-06-13 13:43:34.757413700 +0200
@@ -45,13 +45,13 @@
 
 static inline int blake2b_set_lastnode( blake2b_state *S )
 {
-  S->f[1] = ~0ULL;
+  S->f[1] = -1;
   return 0;
 }
 
 static inline int blake2b_clear_lastnode( blake2b_state *S )
 {
-  S->f[1] = 0ULL;
+  S->f[1] = 0;
   return 0;
 }
 
@@ -60,7 +60,7 @@
 {
   if( S->last_node ) blake2b_set_lastnode( S );
 
-  S->f[0] = ~0ULL;
+  S->f[0] = -1;
   return 0;
 }
 
@@ -68,7 +68,7 @@
 {
   if( S->last_node ) blake2b_clear_lastnode( S );
 
-  S->f[0] = 0ULL;
+  S->f[0] = 0;
   return 0;
 }
 
@@ -145,43 +145,22 @@
   return 0;
 }
 
-#define blake2b_init BLAKE2_IMPL_NAME(blake2b_init)
-#define blake2b_init_param BLAKE2_IMPL_NAME(blake2b_init_param)
-#define blake2b_init_key BLAKE2_IMPL_NAME(blake2b_init_key)
-#define blake2b_update BLAKE2_IMPL_NAME(blake2b_update)
-#define blake2b_final BLAKE2_IMPL_NAME(blake2b_final)
-#define blake2b BLAKE2_IMPL_NAME(blake2b)
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-  int blake2b_init( blake2b_state *S, size_t outlen );
-  int blake2b_init_param( blake2b_state *S, const blake2b_param *P );
-  int blake2b_init_key( blake2b_state *S, size_t outlen, const void *key, size_t keylen );
-  int blake2b_update( blake2b_state *S, const uint8_t *in, size_t inlen );
-  int blake2b_final( blake2b_state *S, uint8_t *out, size_t outlen );
-  int blake2b( uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen );
-#if defined(__cplusplus)
-}
-#endif
-
 /* init xors IV with input parameter block */
 int blake2b_init_param( blake2b_state *S, const blake2b_param *P )
 {
   blake2b_init0( S );
-  uint8_t *p = ( uint8_t * )( P );
+  const uint8_t *p = ( const uint8_t * )( P );
 
   /* IV XOR ParamBlock */
   for( size_t i = 0; i < 8; ++i )
     S->h[i] ^= load64( p + sizeof( S->h[i] ) * i );
 
-  S->outlen = P->digest_length;
   return 0;
 }
 
 
 
-int blake2b_init( blake2b_state *S, size_t outlen )
+int blake2b_init( blake2b_state *S, const uint8_t outlen )
 {
   blake2b_param P[1];
 
@@ -202,7 +181,7 @@
 }
 
 
-int blake2b_init_key( blake2b_state *S, size_t outlen, const void *key, size_t keylen )
+int blake2b_init_key( blake2b_state *S, const uint8_t outlen, const void *key, const uint8_t keylen )
 {
   blake2b_param P[1];
 
@@ -297,8 +276,8 @@
   return 0;
 }
 
-
-int blake2b_update( blake2b_state *S, const uint8_t *in, size_t inlen )
+/* inlen now in bytes */
+int blake2b_update( blake2b_state *S, const uint8_t *in, uint64_t inlen )
 {
   while( inlen > 0 )
   {
@@ -328,11 +307,13 @@
   return 0;
 }
 
-int blake2b_final( blake2b_state *S, uint8_t *out, size_t outlen )
+/* Is this correct? */
+int blake2b_final( blake2b_state *S, uint8_t *out, uint8_t outlen )
 {
-  uint8_t buffer[BLAKE2B_OUTBYTES];
+  uint8_t buffer[BLAKE2B_OUTBYTES] = {0};
 
-  if(S->outlen != outlen) return -1;
+  if( outlen > BLAKE2B_OUTBYTES )
+    return -1;
 
   if( S->buflen > BLAKE2B_BLOCKBYTES )
   {
@@ -354,7 +335,8 @@
   return 0;
 }
 
-int blake2b( uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen )
+/* inlen, at least, should be uint64_t. Others can be size_t. */
+int blake2b( uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen )
 {
   blake2b_state S[1];
 
@@ -363,7 +345,7 @@
 
   if ( NULL == out ) return -1;
 
-  if( NULL == key && key > 0 ) return -1;
+  if( NULL == key ) keylen = 0;
 
   if( keylen > 0 )
   {
@@ -374,8 +356,38 @@
     if( blake2b_init( S, outlen ) < 0 ) return -1;
   }
 
-  if( blake2b_update( S, ( uint8_t * )in, inlen ) < 0 ) return -1;
-  return blake2b_final( S, out, outlen );
+  blake2b_update( S, ( const uint8_t * )in, inlen );
+  blake2b_final( S, out, outlen );
+  return 0;
 }
 
+#if defined(BLAKE2B_SELFTEST)
+#include <string.h>
+#include "blake2-kat.h"
+int main( int argc, char **argv )
+{
+  uint8_t key[BLAKE2B_KEYBYTES];
+  uint8_t buf[KAT_LENGTH];
+
+  for( size_t i = 0; i < BLAKE2B_KEYBYTES; ++i )
+    key[i] = ( uint8_t )i;
+
+  for( size_t i = 0; i < KAT_LENGTH; ++i )
+    buf[i] = ( uint8_t )i;
 
+  for( size_t i = 0; i < KAT_LENGTH; ++i )
+  {
+    uint8_t hash[BLAKE2B_OUTBYTES];
+    blake2b( hash, buf, key, BLAKE2B_OUTBYTES, i, BLAKE2B_KEYBYTES );
+
+    if( 0 != memcmp( hash, blake2b_keyed_kat[i], BLAKE2B_OUTBYTES ) )
+    {
+      puts( "error" );
+      return -1;
+    }
+  }
+
+  puts( "ok" );
+  return 0;
+}
+#endif
diff -urN b2.orig/blake2s.c b2/blake2s.c
--- b2.orig/blake2s.c	2015-06-13 13:43:34.757413700 +0200
+++ b2/blake2s.c	2015-06-13 13:43:34.757413700 +0200
@@ -40,13 +40,13 @@
 
 static inline int blake2s_set_lastnode( blake2s_state *S )
 {
-  S->f[1] = ~0U;
+  S->f[1] = -1;
   return 0;
 }
 
 static inline int blake2s_clear_lastnode( blake2s_state *S )
 {
-  S->f[1] = 0U;
+  S->f[1] = 0;
   return 0;
 }
 
@@ -55,7 +55,7 @@
 {
   if( S->last_node ) blake2s_set_lastnode( S );
 
-  S->f[0] = ~0U;
+  S->f[0] = -1;
   return 0;
 }
 
@@ -63,7 +63,7 @@
 {
   if( S->last_node ) blake2s_clear_lastnode( S );
 
-  S->f[0] = 0U;
+  S->f[0] = 0;
   return 0;
 }
 
@@ -138,43 +138,22 @@
   return 0;
 }
 
-#define blake2s_init BLAKE2_IMPL_NAME(blake2s_init)
-#define blake2s_init_param BLAKE2_IMPL_NAME(blake2s_init_param)
-#define blake2s_init_key BLAKE2_IMPL_NAME(blake2s_init_key)
-#define blake2s_update BLAKE2_IMPL_NAME(blake2s_update)
-#define blake2s_final BLAKE2_IMPL_NAME(blake2s_final)
-#define blake2s BLAKE2_IMPL_NAME(blake2s)
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-  int blake2s_init( blake2s_state *S, size_t outlen );
-  int blake2s_init_param( blake2s_state *S, const blake2s_param *P );
-  int blake2s_init_key( blake2s_state *S, size_t outlen, const void *key, size_t keylen );
-  int blake2s_update( blake2s_state *S, const uint8_t *in, size_t inlen );
-  int blake2s_final( blake2s_state *S, uint8_t *out, size_t outlen );
-  int blake2s( uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen );
-#if defined(__cplusplus)
-}
-#endif
-
 /* init2 xors IV with input parameter block */
 int blake2s_init_param( blake2s_state *S, const blake2s_param *P )
 {
   blake2s_init0( S );
-  uint32_t *p = ( uint32_t * )( P );
+  const uint32_t *p = ( const uint32_t * )( P );
 
   /* IV XOR ParamBlock */
   for( size_t i = 0; i < 8; ++i )
     S->h[i] ^= load32( &p[i] );
 
-  S->outlen = P->digest_length;
   return 0;
 }
 
 
 // Sequential blake2s initialization
-int blake2s_init( blake2s_state *S, size_t outlen )
+int blake2s_init( blake2s_state *S, const uint8_t outlen )
 {
   blake2s_param P[1];
 
@@ -195,7 +174,7 @@
   return blake2s_init_param( S, P );
 }
 
-int blake2s_init_key( blake2s_state *S, size_t outlen, const void *key, size_t keylen )
+int blake2s_init_key( blake2s_state *S, const uint8_t outlen, const void *key, const uint8_t keylen )
 {
   blake2s_param P[1];
 
@@ -288,7 +267,7 @@
 }
 
 
-int blake2s_update( blake2s_state *S, const uint8_t *in, size_t inlen )
+int blake2s_update( blake2s_state *S, const uint8_t *in, uint64_t inlen )
 {
   while( inlen > 0 )
   {
@@ -318,11 +297,12 @@
   return 0;
 }
 
-int blake2s_final( blake2s_state *S, uint8_t *out, size_t outlen )
+int blake2s_final( blake2s_state *S, uint8_t *out, uint8_t outlen )
 {
-  uint8_t buffer[BLAKE2S_OUTBYTES];
+  uint8_t buffer[BLAKE2S_OUTBYTES] = {0};
 
-  if(S->outlen != outlen) return -1;
+  if( outlen > BLAKE2S_OUTBYTES )
+    return -1;
 
   if( S->buflen > BLAKE2S_BLOCKBYTES )
   {
@@ -344,7 +324,7 @@
   return 0;
 }
 
-int blake2s( uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen )
+int blake2s( uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen )
 {
   blake2s_state S[1];
 
@@ -353,7 +333,7 @@
 
   if ( NULL == out ) return -1;
 
-  if ( NULL == key && keylen > 0 ) return -1;
+  if ( NULL == key ) keylen = 0; /* Fail here instead if keylen != 0 and key == NULL? */
 
   if( keylen > 0 )
   {
@@ -364,7 +344,38 @@
     if( blake2s_init( S, outlen ) < 0 ) return -1;
   }
 
-  if( blake2s_update( S, ( uint8_t * )in, inlen ) < 0) return -1;
-  return blake2s_final( S, out, outlen );
+  blake2s_update( S, ( const uint8_t * )in, inlen );
+  blake2s_final( S, out, outlen );
+  return 0;
 }
 
+#if defined(BLAKE2S_SELFTEST)
+#include <string.h>
+#include "blake2-kat.h"
+int main( int argc, char **argv )
+{
+  uint8_t key[BLAKE2S_KEYBYTES];
+  uint8_t buf[KAT_LENGTH];
+
+  for( size_t i = 0; i < BLAKE2S_KEYBYTES; ++i )
+    key[i] = ( uint8_t )i;
+
+  for( size_t i = 0; i < KAT_LENGTH; ++i )
+    buf[i] = ( uint8_t )i;
+
+  for( size_t i = 0; i < KAT_LENGTH; ++i )
+  {
+    uint8_t hash[BLAKE2S_OUTBYTES];
+    blake2s( hash, buf, key, BLAKE2S_OUTBYTES, i, BLAKE2S_KEYBYTES );
+
+    if( 0 != memcmp( hash, blake2s_keyed_kat[i], BLAKE2S_OUTBYTES ) )
+    {
+      puts( "error" );
+      return -1;
+    }
+  }
+
+  puts( "ok" );
+  return 0;
+}
+#endif
